App is a browser game that allows user to "time travel" and make choices for a person in a certain time period. User can start multiple game sessions not affecting each other similar to ChatGPT chats.

When creating a new session user will go through the following steps:
1 user selects year and location
2 LLM generates a (if possible yearly) timeline of historical events that would affect someone born at this time and place and creates possible origins options for character (lower / middle / higher class)
3 user chooses origin dependant on location and time period from the options generated by LLM
4 LLM starts to generate life story of the character of that origin based on events timeline for this location and period in increments of 5 years ending on a "cliffhanger event" that highlights a consequential event for the character (e.g. choosing apprenticeship or a spouse, moving to a different town, etc.). LLM also creates a detailed historically accurate image to illustrate that event. Those events should take into consideration past, current or future events in the timeline (e.g. a choice for a noble to move to St Petersburg at 1916 might lead to them being killed during revolution). User choice is limited to 4 concise options generated by LLM.
5 user chooses one option to proceed and the game reacts to this choice and LLM reacts to it proceeding to step 4 but taking it into the context that results in step 5 unless user dies as a result of their choice (e.g. during a war or famine) or by reaching an age that would be realistically time of death for someone of this background.

# Best Practices

## UI Architecture
- Focus on a single-page experience; treat each major screen as a top-level client component (`"use client"` at the top of every component file).
- Keep component files lean: extract shared UI elements into `src/components/` and custom hooks into `src/hooks/` whenever logic or templates grow beyond ~150 lines.
- Co-locate small helper modules (types, constants) next to their usage but export shared utilities from `src/lib/`.

## State & Data
- Persist user state exclusively in `localStorage`; wrap access in a reusable `useLocalStorage` hook to sync reads/writes and handle JSON parsing.
- Hydrate local state inside `useEffect` to avoid SSR mismatches, even though the project runs entirely on the client.
- Provide optimistic UI updates and debounce writes when persisting large payloads.

## Styling & Theming
- Use Tailwind CSS utility classes for layout and spacing to maintain a consistent visual language.
- Centralize repeated class combinations through small wrapper components or Tailwind component classes to reduce duplication.
- Favor semantic HTML elements; reserve divs for layout wrappers.
- Use `gap-` instead of `space-` to provide spacing between elements

## React & Next.js 16
- Use React Compilerâ€“compatible patterns (avoid inline object literals/functions when possible) to benefit from `babel-plugin-react-compiler`.
- Prefer React 19 features such as `useOptimistic`, `use`, and `useFormStatus` only when they simplify local state; otherwise stick to standard hooks for readability.
- Keep Next.js routing minimal: use the App Router but treat it as a shell around the SPA content; dynamic rendering is unnecessary unless explicitly needed.

## Code Quality
- Run `npm run lint` before commits; keep ESLint warnings at zero.
- Write lightweight component tests for complex hooks/components (e.g., using React Testing Library) when behavior becomes non-trivial.
- Add concise comments only for complex state transitions or non-obvious localStorage quirks.

## Tooling & Workflow
- Use `npm run dev` for local development; `npm run build` should stay green before merging.
- Configure editor formatters to respect Tailwind class sorting and TypeScript auto-imports.
- Monitor bundle size with Next.js Analyzer (`next build --analyze`) if the UI grows significantly.
